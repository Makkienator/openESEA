{"remainingRequest":"C:\\Users\\Marc\\source\\repos\\openESEA\\openESEA_interpreter\\frontend\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\Marc\\source\\repos\\openESEA\\openESEA_interpreter\\frontend\\node_modules\\vue-loader-v16\\dist\\templateLoader.js??ref--6!C:\\Users\\Marc\\source\\repos\\openESEA\\openESEA_interpreter\\frontend\\node_modules\\cache-loader\\dist\\cjs.js??ref--1-0!C:\\Users\\Marc\\source\\repos\\openESEA\\openESEA_interpreter\\frontend\\node_modules\\vue-loader-v16\\dist\\index.js??ref--1-1!C:\\Users\\Marc\\source\\repos\\openESEA\\openESEA_interpreter\\frontend\\src\\views\\organisation\\OrganisationDashboard.vue?vue&type=template&id=05816f42","dependencies":[{"path":"C:\\Users\\Marc\\source\\repos\\openESEA\\openESEA_interpreter\\frontend\\src\\views\\organisation\\OrganisationDashboard.vue","mtime":1708979735272},{"path":"C:\\Users\\Marc\\source\\repos\\openESEA\\openESEA_interpreter\\frontend\\babel.config.js","mtime":1707572265264},{"path":"C:\\Users\\Marc\\source\\repos\\openESEA\\openESEA_interpreter\\frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1741014584802},{"path":"C:\\Users\\Marc\\source\\repos\\openESEA\\openESEA_interpreter\\frontend\\node_modules\\babel-loader\\lib\\index.js","mtime":1741014593746},{"path":"C:\\Users\\Marc\\source\\repos\\openESEA\\openESEA_interpreter\\frontend\\node_modules\\vue-loader-v16\\dist\\templateLoader.js","mtime":1741014602863},{"path":"C:\\Users\\Marc\\source\\repos\\openESEA\\openESEA_interpreter\\frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1741014584802},{"path":"C:\\Users\\Marc\\source\\repos\\openESEA\\openESEA_interpreter\\frontend\\node_modules\\vue-loader-v16\\dist\\index.js","mtime":1741014595374}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IHsgY3JlYXRlQ29tbWVudFZOb2RlIGFzIF9jcmVhdGVDb21tZW50Vk5vZGUsIHJlc29sdmVDb21wb25lbnQgYXMgX3Jlc29sdmVDb21wb25lbnQsIGNyZWF0ZVZOb2RlIGFzIF9jcmVhdGVWTm9kZSwgb3BlbkJsb2NrIGFzIF9vcGVuQmxvY2ssIGNyZWF0ZUVsZW1lbnRCbG9jayBhcyBfY3JlYXRlRWxlbWVudEJsb2NrLCB3aXRoQ3R4IGFzIF93aXRoQ3R4LCBjcmVhdGVFbGVtZW50Vk5vZGUgYXMgX2NyZWF0ZUVsZW1lbnRWTm9kZSwgRnJhZ21lbnQgYXMgX0ZyYWdtZW50IH0gZnJvbSAidnVlIjsKY29uc3QgX2hvaXN0ZWRfMSA9IHsKICBjbGFzczogIm9yZ2FuaXNhdGlvbi1kYXNoYm9hcmQiLAogIHJlZjogImRhc2hib2FyZCIKfTsKY29uc3QgX2hvaXN0ZWRfMiA9IHsKICBrZXk6IDAsCiAgY2xhc3M6ICJzcGlubmVyLWRpdiIKfTsKZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihfY3R4LCBfY2FjaGUsICRwcm9wcywgJHNldHVwLCAkZGF0YSwgJG9wdGlvbnMpIHsKICBjb25zdCBfY29tcG9uZW50X1Byb2dyZXNzU3Bpbm5lciA9IF9yZXNvbHZlQ29tcG9uZW50KCJQcm9ncmVzc1NwaW5uZXIiKTsKICBjb25zdCBfY29tcG9uZW50X0Rhc2hib2FyZEVkaXRpbmdTZWN0aW9uID0gX3Jlc29sdmVDb21wb25lbnQoIkRhc2hib2FyZEVkaXRpbmdTZWN0aW9uIik7CiAgY29uc3QgX2NvbXBvbmVudF9EYXNoYm9hcmQgPSBfcmVzb2x2ZUNvbXBvbmVudCgiRGFzaGJvYXJkIik7CiAgY29uc3QgX2NvbXBvbmVudF9CdXR0b24gPSBfcmVzb2x2ZUNvbXBvbmVudCgiQnV0dG9uIik7CiAgY29uc3QgX2NvbXBvbmVudF9EaWFsb2cgPSBfcmVzb2x2ZUNvbXBvbmVudCgiRGlhbG9nIik7CiAgcmV0dXJuIF9vcGVuQmxvY2soKSwgX2NyZWF0ZUVsZW1lbnRCbG9jayhfRnJhZ21lbnQsIG51bGwsIFtfY3JlYXRlQ29tbWVudFZOb2RlKCIgRGFzaGJvYXJkICIpLCBfY3JlYXRlRWxlbWVudFZOb2RlKCJkaXYiLCBfaG9pc3RlZF8xLCBbX2NyZWF0ZUNvbW1lbnRWTm9kZSgiIFNob3cgc3Bpbm5lciB3aGlsZSBsb2FkaW5nIGRhc2hib2FyZCAiKSwgISRkYXRhLmRhc2hib2FyZExvYWRlZCA/IChfb3BlbkJsb2NrKCksIF9jcmVhdGVFbGVtZW50QmxvY2soImRpdiIsIF9ob2lzdGVkXzIsIFtfY3JlYXRlVk5vZGUoX2NvbXBvbmVudF9Qcm9ncmVzc1NwaW5uZXIsIHsKICAgIGNsYXNzOiAiY2VudGVyLXNwaW5uZXIiCiAgfSldKSkgOiAoX29wZW5CbG9jaygpLCBfY3JlYXRlRWxlbWVudEJsb2NrKF9GcmFnbWVudCwgewogICAga2V5OiAxCiAgfSwgW19jcmVhdGVDb21tZW50Vk5vZGUoIiBJZiBkYXNoYm9hcmQgaXMgbG9hZGVkLCBzaG93IGRhc2hib2FyZCBhbmQgZWRpdGluZyBzZWN0aW9uICIpLCBfY3JlYXRlRWxlbWVudFZOb2RlKCJkaXYiLCBudWxsLCBbX2NyZWF0ZUNvbW1lbnRWTm9kZSgiIEVkaXRpbmcgU2VjdGlvbiAiKSwgX2NyZWF0ZVZOb2RlKF9jb21wb25lbnRfRGFzaGJvYXJkRWRpdGluZ1NlY3Rpb24sIHsKICAgIG9uU2F2ZUJ1dHRvbkNsaWNrZWQ6ICRvcHRpb25zLnNhdmVEYXNoYm9hcmRUb0RhdGFiYXNlLAogICAgb25EaXNjYXJkQnV0dG9uQ2xpY2tlZDogJG9wdGlvbnMuZGlzY2FyZENoYW5nZXMKICB9LCBudWxsLCA4IC8qIFBST1BTICovLCBbIm9uU2F2ZUJ1dHRvbkNsaWNrZWQiLCAib25EaXNjYXJkQnV0dG9uQ2xpY2tlZCJdKSwgX2NyZWF0ZUNvbW1lbnRWTm9kZSgiIEFjdHVhbCBkYXNoYm9hcmQgIiksIF9jcmVhdGVWTm9kZShfY29tcG9uZW50X0Rhc2hib2FyZCksIF9jcmVhdGVDb21tZW50Vk5vZGUoIiBEaWFsb2cgc2hvd2luZyB0aGF0IHRoZXJlIGFyZSB1bnNhdmVkIGNoYW5nZXMgIiksIF9jcmVhdGVWTm9kZShfY29tcG9uZW50X0RpYWxvZywgewogICAgcmVmOiAiZGlhbG9nIiwKICAgIHZpc2libGU6ICRkYXRhLnNob3dEaWFsb2csCiAgICAib25VcGRhdGU6dmlzaWJsZSI6IF9jYWNoZVswXSB8fCAoX2NhY2hlWzBdID0gJGV2ZW50ID0+ICRkYXRhLnNob3dEaWFsb2cgPSAkZXZlbnQpLAogICAgbW9kYWw6ICIiLAogICAgaGVhZGVyOiAnVGhlcmUgYXJlIHVuc2F2ZWQgY2hhbmdlcyB0byB0aGUgZGFzaGJvYXJkLiBEbyB5b3Ugd2FudCB0byBzYXZlIHRoZXNlIGNoYW5nZXM/JwogIH0sIHsKICAgIGZvb3RlcjogX3dpdGhDdHgoKCkgPT4gW19jcmVhdGVWTm9kZShfY29tcG9uZW50X0J1dHRvbiwgewogICAgICBsYWJlbDogIkNhbmNlbCIsCiAgICAgIGljb246ICJwaSBwaS10aW1lcyIsCiAgICAgIG9uQ2xpY2s6ICRvcHRpb25zLmNsb3NlRGlhbG9nLAogICAgICB0ZXh0OiAiIgogICAgfSwgbnVsbCwgOCAvKiBQUk9QUyAqLywgWyJvbkNsaWNrIl0pLCBfY3JlYXRlVk5vZGUoX2NvbXBvbmVudF9CdXR0b24sIHsKICAgICAgbGFiZWw6ICJEaXNjYXJkIENoYW5nZXMiLAogICAgICBpY29uOiAicGkgcGktdHJhc2giLAogICAgICBjbGFzczogInAtYnV0dG9uLWRhbmdlciBwLWJ1dHRvbi1zbSIsCiAgICAgIG9uQ2xpY2s6ICRvcHRpb25zLmRpc2NhcmRDaGFuZ2VzLAogICAgICB0ZXh0OiAiIgogICAgfSwgbnVsbCwgOCAvKiBQUk9QUyAqLywgWyJvbkNsaWNrIl0pLCBfY3JlYXRlVk5vZGUoX2NvbXBvbmVudF9CdXR0b24sIHsKICAgICAgbGFiZWw6ICJTYXZlIENoYW5nZXMiLAogICAgICBpY29uOiAicGkgcGktY2hlY2siLAogICAgICBjbGFzczogInAtYnV0dG9uLXN1Y2Nlc3MgcC1idXR0b24tc20iLAogICAgICBvbkNsaWNrOiAkb3B0aW9ucy5zYXZlQ2hhbmdlcywKICAgICAgYXV0b2ZvY3VzOiAiIgogICAgfSwgbnVsbCwgOCAvKiBQUk9QUyAqLywgWyJvbkNsaWNrIl0pXSksCiAgICBfOiAxIC8qIFNUQUJMRSAqLwogIH0sIDggLyogUFJPUFMgKi8sIFsidmlzaWJsZSJdKV0pXSwgMjExMiAvKiBTVEFCTEVfRlJBR01FTlQsIERFVl9ST09UX0ZSQUdNRU5UICovKSldLCA1MTIgLyogTkVFRF9QQVRDSCAqLyldLCAyMTEyIC8qIFNUQUJMRV9GUkFHTUVOVCwgREVWX1JPT1RfRlJBR01FTlQgKi8pOwp9"},{"version":3,"names":["class","ref","_createCommentVNode","_createElementVNode","_hoisted_1","$data","dashboardLoaded","_createElementBlock","_hoisted_2","_createVNode","_component_ProgressSpinner","_Fragment","key","_component_DashboardEditingSection","onSaveButtonClicked","$options","saveDashboardToDatabase","onDiscardButtonClicked","discardChanges","_component_Dashboard","_component_Dialog","visible","showDialog","$event","modal","header","footer","_withCtx","_component_Button","label","icon","onClick","closeDialog","text","saveChanges","autofocus"],"sources":["C:\\Users\\Marc\\source\\repos\\openESEA\\openESEA_interpreter\\frontend\\src\\views\\organisation\\OrganisationDashboard.vue"],"sourcesContent":["<template>\r\n\r\n    <!-- Dashboard -->\r\n    <div class=\"organisation-dashboard\" ref=\"dashboard\">\r\n\r\n        <!-- Show spinner while loading dashboard -->\r\n        <div v-if=\"!dashboardLoaded\" class=\"spinner-div\">\r\n            <ProgressSpinner class=\"center-spinner\"></ProgressSpinner>\r\n        </div>\r\n\r\n        <!-- If dashboard is loaded, show dashboard and editing section -->\r\n        <div v-else>\r\n            <!-- Editing Section -->\r\n            <DashboardEditingSection @saveButtonClicked=\"saveDashboardToDatabase\" @discardButtonClicked=\"discardChanges\"></DashboardEditingSection>\r\n            <!-- Actual dashboard -->\r\n            <Dashboard></Dashboard>\r\n\r\n            <!-- Dialog showing that there are unsaved changes -->\r\n            <Dialog ref=\"dialog\" v-model:visible=\"showDialog\" modal\r\n                :header=\"'There are unsaved changes to the dashboard. Do you want to save these changes?'\">\r\n\r\n                <!-- Footer with buttons for options: Cancel, Discard Changes, Save Changes -->\r\n                <template #footer>\r\n                    <Button label=\"Cancel\" icon=\"pi pi-times\"\r\n                        @click=\"closeDialog\" text>\r\n                    </Button>\r\n                    <Button label=\"Discard Changes\" icon=\"pi pi-trash\" class=\"p-button-danger p-button-sm\"\r\n                        @click=\"discardChanges\" text>\r\n                    </Button>\r\n                    <Button label=\"Save Changes\" icon=\"pi pi-check\" class=\"p-button-success p-button-sm\"\r\n                        @click=\"saveChanges\" autofocus>\r\n                    </Button>\r\n                </template>\r\n\r\n            </Dialog>\r\n\r\n        </div>\r\n\r\n    </div>\r\n\r\n</template>\r\n\r\n<script>\r\nimport { isEqual, cloneDeep } from 'lodash'\r\n\r\nimport { mapState, mapGetters, mapMutations, mapActions } from 'vuex'\r\n\r\nimport EseaAccountService from '../../services/EseaAccountService.js'\r\nimport SurveyResponseService from '../../services/SurveyResponseService.js'\r\nimport DirectIndicatorService from '../../services/DirectIndicatorService.js'\r\nimport IndirectIndicatorService from '../../services/IndirectIndicatorService.js'\r\n\r\nimport Dashboard from '../../components/dashboard/Dashboard.vue'\r\nimport DashboardEditingSection from '../../components/dashboard/DashboardEditingSection.vue'\r\n\r\nimport ProgressSpinner from 'primevue/progressspinner'\r\nimport Dialog from 'primevue/dialog'\r\n\r\nexport default {\r\n    components: {\r\n        DashboardEditingSection,\r\n        Dashboard,\r\n\r\n        ProgressSpinner,\r\n        Dialog\r\n    },\r\n    data () {\r\n        return {\r\n            // Route parameters for organisation and dashboard ids\r\n            organisationId: this.$route.params.OrganisationId,\r\n            dashboardId: this.$route.params.DashboardId,\r\n\r\n            dashboardLoaded: false,\r\n\r\n            initialDashboard: null,\r\n\r\n            showDialog: false,\r\n\r\n            fetchSuggestionsTimer: null,\r\n\r\n            testing: true\r\n        }\r\n    },\r\n    computed: {\r\n        // ...mapState('network', ['networks']),\r\n        ...mapState('organisation', ['organisation']),\r\n        ...mapState('dashboardModel', ['dashboard', 'selectionConfig']),\r\n            permission () {\r\n                if (this.organisation.accesLevel) {\r\n                    const accesLevel = this.organisation.accesLevel\r\n                    if (accesLevel === 'admin' || accesLevel === 'network admin') {\r\n                        return true\r\n                    }\r\n                }\r\n                return false\r\n            }\r\n    },\r\n    watch: {\r\n        dashboard: {\r\n            handler: 'updateRLModel',\r\n            deep: true\r\n        }\r\n    },\r\n    async mounted () {\r\n        if (!this.testing) {\r\n            this.fetchSuggestionsTimer = setInterval(this.fetchDashboardSuggestions, 10000)\r\n        }\r\n    },\r\n    async unmounted () {\r\n        if (!this.testing) {\r\n            clearInterval(this.fetchSuggestionsTimer)\r\n        }\r\n    },\r\n    async beforeUnmount () {\r\n        window.removeEventListener('beforeunload', this.unload)\r\n    },\r\n    async created () {\r\n        window.addEventListener('beforeunload', this.unload)\r\n\r\n        // Fetch latest version of dashboard\r\n        await this.fetchDashboard({ id: parseInt(this.dashboardId) })\r\n        // Load dashboard from fetched dashboard\r\n        await this.loadDashboardFromDatabase()\r\n        await this.setInitialDashboard()\r\n\r\n        // Initialize RL model\r\n        if (!this.testing) {\r\n            await this.initializeRLModel()\r\n        }\r\n    },\r\n    async beforeRouteLeave (to, from, next) {\r\n        console.log('Leaving route')\r\n        if (!this.dashboardLoaded) next(true)\r\n        if (!this.dashboardSaved()) {\r\n            this.showDialog = true\r\n            next(false)\r\n        } else {\r\n            if (!this.testing) {\r\n                await this.stopRLModel()\r\n            }\r\n            next(true)\r\n        }\r\n    },\r\n    methods: {\r\n        ...mapGetters('dashboard', ['getDashboard', 'getDashboards']),\r\n        ...mapActions('dashboard', ['setDashboard', 'updateDashboard', 'fetchDashboard']),\r\n\r\n        ...mapGetters('dashboardData', ['getIndicatorDataSets', 'getIndicatorFields', 'getIndicators', 'getVisualisationDatasets']),\r\n        ...mapMutations('dashboardData', ['setIndicators', 'setIndicatorData', 'setIndicatorFields']),\r\n        ...mapActions('dashboardData', ['createIndicatorDataSets']),\r\n\r\n        ...mapGetters('dashboardModel', ['getDashboardModel', 'getMethods', 'getOverview', 'getContainers', 'getVisualisations', 'getVisualisationTitle', 'getVisualisationType', 'getCategoryLimit']),\r\n        ...mapActions('dashboardModel', ['createDashboardModel']),\r\n\r\n        ...mapActions('dashboardSuggestions', ['buildDashboardRLModel', 'updateDashboardRLModel', 'deleteDashboardRLModel', 'fetchDashboardSuggestions']),\r\n\r\n        setInitialDashboard () {\r\n            this.initialDashboard = cloneDeep(this.dashboard)\r\n        },\r\n        dashboardSaved () {\r\n            return isEqual(this.dashboard, this.initialDashboard)\r\n        },\r\n\r\n        async unload (event) {\r\n            console.log('Unloading page')\r\n            if (!this.dashboardLoaded) return\r\n            // Prevent page unloading if dashboard is not saved\r\n            if (!this.dashboardSaved()) {\r\n                event.preventDefault()\r\n                event.returnValue = '' // Required for older browsers\r\n            }\r\n        },\r\n        async initializeRLModel () {\r\n            // Wait 2 seconds before visualisations are loaded\r\n            const sleep = (delay) => new Promise((resolve) => setTimeout(resolve, delay))\r\n            console.log('datasets:')\r\n            console.log(await this.getIndicatorDataSets()())\r\n            await sleep(2000)\r\n            // Build new RL Model and set interval for fetching suggestions\r\n            const dashboard = await this.collectDashboardInfo()\r\n            console.log(dashboard)\r\n            if (!this.testing) {\r\n                await this.buildDashboardRLModel({ data: { dashboard: dashboard } })\r\n            }\r\n        },\r\n        async collectDashboardInfo () {\r\n            // Initialize list with info for all visualisations\r\n            var visualisationInfoList = []\r\n\r\n            // Select current overview\r\n            const overviewId = this.selectionConfig?.overviewId\r\n            var selectionConfigCurrent = { overviewId: overviewId }\r\n\r\n            // Get all containers with possible visualisations, if no containers, return\r\n            const containers = await this.getContainers()(selectionConfigCurrent)\r\n            if (!containers) return visualisationInfoList\r\n\r\n            // Dashboard size\r\n            const dashboardWidth = this.$refs.dashboard.clientWidth\r\n            const dashboardHeight = this.$refs.dashboard.clientHeight\r\n            const dashboardDisplayArea = dashboardWidth * dashboardHeight\r\n\r\n            // Get visualisation datasets\r\n            var visualisationDatasets = await this.getVisualisationDatasets()()\r\n            // Collect visualisations for each container\r\n            for (let containerId = 0; containerId < containers.length; containerId++) {\r\n                const containerPosition = containers[containerId].Position\r\n                const containerWidth = (containerPosition['X End'] - containerPosition['X Start']) * dashboardWidth / 100\r\n                const containerHeight = (containerPosition['Y End'] - containerPosition['Y Start']) * dashboardHeight / 100\r\n\r\n                // Update selection to current conainer\r\n                selectionConfigCurrent.containerId = containerId\r\n                // Get all visualisation for this container\r\n                const visualisations = await this.getVisualisations()(selectionConfigCurrent)\r\n                // Get info for each visualisation\r\n                for (let visualisationId = 0; visualisationId < visualisations.length; visualisationId++) {\r\n                    const visualisationPosition = visualisations[visualisationId].Position\r\n                    const xStartPixels = dashboardWidth * containerPosition['X Start'] + containerWidth * visualisationPosition['X Start']\r\n                    const xEndPixels = dashboardWidth * containerPosition['X End'] + containerWidth * visualisationPosition['X End']\r\n                    const yStartPixels = dashboardHeight * containerPosition['Y Start'] + containerHeight * visualisationPosition['Y Start']\r\n                    const yEndPixels = dashboardHeight * containerPosition['Y End'] + containerHeight * visualisationPosition['Y End']\r\n                    const visualisationDisplayArea = (xEndPixels - xStartPixels) * (yEndPixels - yStartPixels)\r\n\r\n                    // Update selection to current visualisation\r\n                    selectionConfigCurrent.visualisationId = visualisationId\r\n\r\n                    // Get dataset for this visualisation\r\n                    var visualisationData = null\r\n\r\n                    for (const visualisationDataset of visualisationDatasets) {\r\n                        const config = visualisationDataset.config\r\n                        const dataset = visualisationDataset.dataset\r\n                        if (isEqual(config, selectionConfigCurrent)) {\r\n                            visualisationData = dataset\r\n                            break\r\n                        }\r\n                    }\r\n\r\n                    // Get visualisation type\r\n                    const visualisationType = await this.getVisualisationType()(selectionConfigCurrent)\r\n                    const visualisationTitle = await this.getVisualisationTitle()(selectionConfigCurrent)\r\n                    const categoryLimit = await this.getCategoryLimit()(selectionConfigCurrent)\r\n\r\n                    const categoryField = Object.keys(visualisationData?.mapping).find(fieldKey => fieldKey === 'Category Field')\r\n                    const allCategories = categoryField ? visualisationData?.data?.map(row => row[categoryField]) : []\r\n                    const distinctCategories = new Set(allCategories)\r\n\r\n                    const numberOfCategories = distinctCategories?.size\r\n                    const numberOfDataPoints = visualisationData?.data?.length ?? 0\r\n                    const amountOfValueFields = Object.keys(visualisationData?.mapping).filter(fieldKey => fieldKey.includes('Value Field')).length\r\n\r\n                    // Gather all visualisation information into one object\r\n                    var visualisationInfo = {}\r\n                    visualisationInfo['Selection Configuration'] = cloneDeep(selectionConfigCurrent) // For applying this to the correct visualisation\r\n                    visualisationInfo['Visualisation Type'] = visualisationType\r\n                    visualisationInfo['Visualisation Title'] = visualisationTitle\r\n                    visualisationInfo['Category Items'] = numberOfCategories\r\n                    visualisationInfo['Data Items'] = numberOfDataPoints * amountOfValueFields\r\n                    visualisationInfo['Item Limit Enabled'] = categoryLimit > 0\r\n                    visualisationInfo['Item Limit'] = categoryLimit ?? 0\r\n                    visualisationInfo['Display Area'] = visualisationDisplayArea\r\n                    visualisationInfo.Position = { 'X Start': xStartPixels, 'X End': xEndPixels, 'Y Start': yStartPixels, 'Y End': yEndPixels }\r\n                    visualisationInfoList.push(visualisationInfo)\r\n                }\r\n            }\r\n            return { Visualisations: visualisationInfoList, 'Display Area': dashboardDisplayArea }\r\n        },\r\n        async updateRLModel () {\r\n            if (this.testing) return\r\n            // Wait 2 seconds before visualisations are loaded\r\n            const sleep = (delay) => new Promise((resolve) => setTimeout(resolve, delay))\r\n            await sleep(2000)\r\n            // Update RL Model and set interval for fetching suggestions\r\n            const dashboard = await this.collectDashboardInfo()\r\n            await this.updateDashboardRLModel({ data: { dashboard: dashboard } })\r\n            // Reset timer for fetching suggestions\r\n            if (!this.testing) {\r\n                clearInterval(this.fetchSuggestionsTimer)\r\n                this.fetchSuggestionsTimer = setInterval(this.fetchDashboardSuggestions, 10000)\r\n            }\r\n        },\r\n        async stopRLModel () {\r\n            // Delete RL model and clear timer\r\n            await this.deleteDashboardRLModel({ data: {} })\r\n            clearInterval(this.fetchSuggestionsTimer)\r\n        },\r\n        async saveChanges () {\r\n            await this.saveDashboardToDatabase()\r\n            this.closeDialog()\r\n        },\r\n        async discardChanges () {\r\n            const oldDashboard = cloneDeep(this.initialDashboard)\r\n            await this.loadDashboardModel(oldDashboard)\r\n            this.closeDialog()\r\n        },\r\n        closeDialog () {\r\n            this.showDialog = false\r\n        },\r\n\r\n        async loadDashboardFromDatabase () {\r\n            // Load dashboard from database\r\n            const dashboard = await this.getDashboard()\r\n            // Set as current dashboard\r\n            await this.setDashboard(dashboard)\r\n\r\n            // Get dashboard model specification\r\n            const model = dashboard.specification\r\n            // Load dashboard model\r\n            await this.loadDashboardModel(model)\r\n            // Load dashboard data\r\n            await this.loadDashboardData()\r\n            // When everything is ready show dashboard\r\n            this.dashboardLoaded = true\r\n        },\r\n        async saveDashboardToDatabase () {\r\n            if (!this.permission) {\r\n                console.log('No permission to save dashboards!')\r\n                return\r\n            } else {\r\n                console.log('Permission to save dashboard!')\r\n            }\r\n            // Get current dashboard model\r\n            const dashboardModel = await this.getDashboardModel()()\r\n            // Combine dashboard id with dashboard model specification\r\n            const dashboardId = parseInt(this.dashboardId)\r\n            const data = { id: dashboardId, data: dashboardModel }\r\n            // Send this data to update the dashboard in the database\r\n            await this.updateDashboard(data)\r\n            // Signal that changes are saved\r\n            await this.setInitialDashboard()\r\n        },\r\n        async loadDashboardModel (model) {\r\n            // Force reload by first setting model to null\r\n            await this.createDashboardModel(null)\r\n            // Then set dashboard model\r\n            const payload = { value: model }\r\n            await this.createDashboardModel(payload)\r\n        },\r\n        async loadDashboardData () {\r\n            // Retrieve and save all indicators of the given methods\r\n            const indicators = await this.retrieveIndicators()\r\n            await this.setIndicators(indicators)\r\n\r\n            // Retrieve and save all data for the indicators of the given methods\r\n            const indicatorData = await this.retrieveIndicatorData()\r\n            await this.setIndicatorData(indicatorData)\r\n\r\n            // Create data sets for each indicator\r\n            await this.createIndicatorDataSets()\r\n        },\r\n        async retrieveIndicators () {\r\n            const methodIds = await this.getMethods()()\r\n            var indicators = []\r\n            for (var methodId of methodIds) {\r\n                const directIndicators = await DirectIndicatorService.get({ mId: methodId })\r\n                console.log(directIndicators)\r\n                if (!directIndicators?.error || directIndicators?.error?.response?.status === 404) {\r\n                    for (var directIndicator of (directIndicators?.response?.data || [])) {\r\n                        indicators.push(directIndicator)\r\n                    }\r\n                }\r\n                const indirectIndicators = await IndirectIndicatorService.get({ mId: methodId })\r\n                console.log(indirectIndicators)\r\n                if (!indirectIndicators?.error || indirectIndicators?.error?.response?.status === 404) {\r\n                    for (var indirectIndicator of (indirectIndicators?.response?.data || [])) {\r\n                        indicators.push(indirectIndicator)\r\n                    }\r\n                }\r\n            }\r\n            // console.log(indicators)\r\n            indicators = indicators?.map(el => ({ name: el.name, key: el.key }))\r\n            return indicators\r\n        },\r\n        async retrieveIndicatorData () {\r\n            // Determine current organisation and targeted methods for dashboard\r\n            const methodIds = await this.getMethods()()\r\n            const organisationId = this.organisationId\r\n\r\n            /* Get the data from the esea accounts of the current organisation (by looking at the question responses in the survey responses) */\r\n            var eseaData = []\r\n\r\n            // Get esea accounts for this organisation\r\n            const eseaAccountsRequest = await EseaAccountService.get({ oId: organisationId })\r\n            if (eseaAccountsRequest.error) return\r\n            const eseaAccounts = eseaAccountsRequest.response.data\r\n\r\n            // Loop over esea accounts\r\n            for (var eseaAccount of eseaAccounts) {\r\n                const eseaAccountId = eseaAccount.id\r\n                // Get year and method of this esea account\r\n                const eseaAccountYear = eseaAccount.year\r\n                const eseaMethod = eseaAccount.method\r\n\r\n                // If this esea account is not for a targeted method, skip this esea account\r\n                if (!methodIds.includes(eseaMethod)) continue\r\n\r\n                // Get all survey responses for this esea account\r\n                const surveyResponseRequest = await SurveyResponseService.get({ oId: organisationId, eaId: eseaAccountId })\r\n                if (surveyResponseRequest.error) continue\r\n                const surveyResponses = surveyResponseRequest.response.data\r\n\r\n                // Loop over survey responses\r\n                for (var surveyResponse of surveyResponses) {\r\n                    // Get responses to questions\r\n                    const questionResponses = surveyResponse.question_responses\r\n\r\n                    // Loop over all questions\r\n                    for (var questionResponse of questionResponses) {\r\n                        // Retrieve indicator data and the given values\r\n                        const directIndicatorKey = questionResponse.direct_indicator_key\r\n                        const directIndicatorValue = questionResponse.value ?? questionResponse.values\r\n                        const multipleChoice = questionResponse.value === null\r\n\r\n                        // Store indicator data\r\n                        eseaData.push({\r\n                            'Indicator Key': directIndicatorKey,\r\n                            Value: directIndicatorValue,\r\n                            Year: eseaAccountYear,\r\n                            'Multiple Choice': multipleChoice\r\n                            // 'Esea Account Id': eseaAccountId,\r\n                            // 'Method Id': eseaMethod,\r\n                            // 'Indicator Id': directIndicatorId\r\n                        })\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Return the data for all indicators\r\n            return eseaData\r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style>\r\n.organisation-dashboard {\r\n    min-height: 600px;\r\n    position: relative;\r\n\r\n    font-family: Arial, Helvetica, sans-serif;\r\n    height: 100%;\r\n\r\n    /* Handle edit area element */\r\n    --edit-area-width: 200px;\r\n    --edit-area-current-width: 0px;\r\n    --edit-sidebar-width: 20px;\r\n}\r\n.spinner-div {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n</style>\r\n"],"mappings":";;EAGSA,KAAK,EAAC,wBAAwB;EAACC,GAAG,EAAC;;;;EAGPD,KAAK,EAAC;;;;;;;;6DAJvCE,mBAAA,eAAkB,EAClBC,mBAAA,CAmCM,OAnCNC,UAmCM,GAjCFF,mBAAA,0CAA6C,E,CACjCG,KAAA,CAAAC,eAAe,I,cAA3BC,mBAAA,CAEM,OAFNC,UAEM,GADFC,YAAA,CAA0DC,0BAAA;IAAzCV,KAAK,EAAC;EAAgB,G,oBAI3CO,mBAAA,CAyBMI,SAAA;IAAAC,GAAA;EAAA,IA1BNV,mBAAA,gEAAmE,EACnEC,mBAAA,CAyBM,cAxBFD,mBAAA,qBAAwB,EACxBO,YAAA,CAAuII,kCAAA;IAA7GC,mBAAiB,EAAEC,QAAA,CAAAC,uBAAuB;IAAGC,sBAAoB,EAAEF,QAAA,CAAAG;8EAC7FhB,mBAAA,sBAAyB,EACzBO,YAAA,CAAuBU,oBAAA,GAEvBjB,mBAAA,mDAAsD,EACtDO,YAAA,CAgBSW,iBAAA;IAhBDnB,GAAG,EAAC,QAAQ;IAASoB,OAAO,EAAEhB,KAAA,CAAAiB,UAAU;4DAAVjB,KAAA,CAAAiB,UAAU,GAAAC,MAAA;IAAEC,KAAK,EAAL,EAAK;IAClDC,MAAM,EAAE;;IAGEC,MAAM,EAAAC,QAAA,CACb,MAES,CAFTlB,YAAA,CAESmB,iBAAA;MAFDC,KAAK,EAAC,QAAQ;MAACC,IAAI,EAAC,aAAa;MACpCC,OAAK,EAAEhB,QAAA,CAAAiB,WAAW;MAAEC,IAAI,EAAJ;0CAEzBxB,YAAA,CAESmB,iBAAA;MAFDC,KAAK,EAAC,iBAAiB;MAACC,IAAI,EAAC,aAAa;MAAC9B,KAAK,EAAC,6BAA6B;MACjF+B,OAAK,EAAEhB,QAAA,CAAAG,cAAc;MAAEe,IAAI,EAAJ;0CAE5BxB,YAAA,CAESmB,iBAAA;MAFDC,KAAK,EAAC,cAAc;MAACC,IAAI,EAAC,aAAa;MAAC9B,KAAK,EAAC,8BAA8B;MAC/E+B,OAAK,EAAEhB,QAAA,CAAAmB,WAAW;MAAEC,SAAS,EAAT","ignoreList":[]}]}