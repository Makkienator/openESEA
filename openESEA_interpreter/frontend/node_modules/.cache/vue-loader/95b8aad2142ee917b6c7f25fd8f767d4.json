{"remainingRequest":"C:\\Users\\Marc\\source\\repos\\openESEA\\openESEA_interpreter\\frontend\\node_modules\\vue-loader-v16\\dist\\index.js??ref--1-1!C:\\Users\\Marc\\source\\repos\\openESEA\\openESEA_interpreter\\frontend\\src\\components\\dashboard\\Visualisation.vue?vue&type=style&index=0&id=750a7690&lang=css","dependencies":[{"path":"C:\\Users\\Marc\\source\\repos\\openESEA\\openESEA_interpreter\\frontend\\src\\components\\dashboard\\Visualisation.vue","mtime":1707572265293},{"path":"C:\\Users\\Marc\\source\\repos\\openESEA\\openESEA_interpreter\\frontend\\node_modules\\css-loader\\dist\\cjs.js","mtime":1741014587743},{"path":"C:\\Users\\Marc\\source\\repos\\openESEA\\openESEA_interpreter\\frontend\\node_modules\\vue-loader-v16\\dist\\stylePostLoader.js","mtime":1741014602245},{"path":"C:\\Users\\Marc\\source\\repos\\openESEA\\openESEA_interpreter\\frontend\\node_modules\\postcss-loader\\src\\index.js","mtime":1741014592996},{"path":"C:\\Users\\Marc\\source\\repos\\openESEA\\openESEA_interpreter\\frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1741014584802},{"path":"C:\\Users\\Marc\\source\\repos\\openESEA\\openESEA_interpreter\\frontend\\node_modules\\vue-loader-v16\\dist\\index.js","mtime":1741014595374}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:DQoubG9hZGluZy1jb250YWluZXIgew0KICBkaXNwbGF5OiBmbGV4Ow0KICBhbGlnbi1pdGVtczogY2VudGVyOw0KICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsNCiAgd2lkdGg6IDEwMCU7DQogIGhlaWdodDogMTAwJTsNCn0NCi5wcm9ncmVzcy1zcGlubmVyIHsNCiAgICBtYXgtaGVpZ2h0OiAxMDAlOw0KICAgIG1heC13aWR0aDogMTAwJTsNCn0NCg=="},{"version":3,"sources":["C:\\Users\\Marc\\source\\repos\\openESEA\\openESEA_interpreter\\frontend\\src\\components\\dashboard\\Visualisation.vue"],"names":[],"mappings":";AAkdA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;EACjB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;EACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EACnB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EACvB,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;EACX,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;AACd;AACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;IACd,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IAChB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;AACnB","file":"C:/Users/Marc/source/repos/openESEA/openESEA_interpreter/frontend/src/components/dashboard/Visualisation.vue","sourceRoot":"","sourcesContent":["<template>\r\n    <div class=\"visualisation\" v-on:click=\"isClicked\" :style=\"styleObject\">\r\n        <!-- Display visualisation of type `visualisationComponent` and giving the `dataSet` object when this is loaded -->\r\n        <component v-if=\"dataSet\" :is=\"visualisationComponent\"\r\n            :chartData=\"dataSet\">\r\n        </component>\r\n        <!-- While waiting, display progress spinner -->\r\n        <div v-else class=\"loading-container\">\r\n            <ProgressSpinner class=\"progress-spinner\">\r\n            </ProgressSpinner>\r\n        </div>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nimport { mapGetters, mapActions } from 'vuex'\r\n\r\nimport EmptyVisualisation from './visualisations/charts/EmptyVisualisation.vue'\r\nimport SingleValueDisplay from './visualisations/charts/SingleValueDisplay.vue'\r\nimport FractionalValueDisplay from './visualisations/charts/FractionalValueDisplay.vue'\r\nimport ProgressBar from './visualisations/charts/ProgressBar.vue'\r\nimport RadialProgressBar from './visualisations/charts/RadialProgressBar.vue'\r\nimport PieChart from './visualisations/charts/PieChart.vue'\r\nimport BarChart from './visualisations/charts/BarChart.vue'\r\nimport GroupedBarChart from './visualisations/charts/GroupedBarChart.vue'\r\nimport StackedBarChart from './visualisations/charts/StackedBarChart.vue'\r\nimport LineChart from './visualisations/charts/LineChart.vue'\r\nimport MultiSeriesLineChart from './visualisations/charts/MultiSeriesLineChart.vue'\r\nimport Table from './visualisations/tables/Table.vue'\r\n\r\nimport ProgressSpinner from 'primevue/progressspinner'\r\n\r\nexport default {\r\n    components: {\r\n        EmptyVisualisation,\r\n        SingleValueDisplay,\r\n        FractionalValueDisplay,\r\n        ProgressBar,\r\n        RadialProgressBar,\r\n        PieChart,\r\n        BarChart,\r\n        GroupedBarChart,\r\n        StackedBarChart,\r\n        LineChart,\r\n        MultiSeriesLineChart,\r\n        Table,\r\n\r\n        ProgressSpinner\r\n    },\r\n    props: {\r\n        config: { type: Object, required: true }\r\n    },\r\n    data () {\r\n        return {\r\n            dataSet: null\r\n        }\r\n    },\r\n    computed: {\r\n        visualisation: {\r\n            get () { return this.getVisualisation()(this.config) }\r\n        },\r\n        visualisationTitle: {\r\n            get () { return this.getVisualisationTitle()(this.config) }\r\n        },\r\n        visualisationType: {\r\n            get () { return this.getVisualisationType()(this.config) }\r\n        },\r\n        visualisationComponent: {\r\n            get () {\r\n                switch (this.visualisationType) {\r\n                    case 'Single Value Display':\r\n                        return 'SingleValueDisplay'\r\n                    case 'Fractional Value Display':\r\n                        return 'FractionalValueDisplay'\r\n                    case 'Progress Bar':\r\n                        return 'ProgressBar'\r\n                    case 'Radial Progress Bar':\r\n                        return 'RadialProgressBar'\r\n                    case 'Pie Chart':\r\n                        return 'PieChart'\r\n                    case 'Bar Chart':\r\n                        return 'BarChart'\r\n                    case 'Grouped Bar Chart':\r\n                        return 'GroupedBarChart'\r\n                    case 'Stacked Bar Chart':\r\n                        return 'StackedBarChart'\r\n                    case 'Line Chart':\r\n                        return 'LineChart'\r\n                    case 'Multi-Series Line Chart':\r\n                        return 'MultiSeriesLineChart'\r\n                    case 'Table':\r\n                        return 'Table'\r\n                    default:\r\n                        return 'EmptyVisualisation'\r\n                }\r\n            }\r\n        },\r\n        position: {\r\n            get () { return this.getVisualisationPosition()(this.config) }\r\n        },\r\n        styleObject () {\r\n            var styleObject = {}\r\n            const position = this.position\r\n            if (position) {\r\n                styleObject.position = 'absolute'\r\n                styleObject.left = position['X Start'].toString() + '%'\r\n                styleObject.right = (100 - position['X End'].toString()) + '%'\r\n                styleObject.bottom = position['Y Start'].toString() + '%'\r\n                styleObject.top = (100 - position['Y End'].toString()) + '%'\r\n            }\r\n            return styleObject\r\n        }\r\n    },\r\n    watch: {\r\n        visualisation: {\r\n            handler: 'createAndSaveDataset',\r\n            deep: true\r\n        }\r\n    },\r\n    async created () {\r\n        await this.createAndSaveDataset()\r\n    },\r\n    methods: {\r\n        ...mapGetters('dashboardData', ['getIndicatorData', 'getIndicatorDataSet', 'getVisualisationDatasets']),\r\n        ...mapActions('dashboardData', ['saveVisualisationDataset']),\r\n        ...mapGetters('dashboardModel', ['getOverviewFilters', 'getVisualisation', 'getDataDisplay', 'getDataConfiguration', 'getVisualisationFilters', 'getValueField', 'getValueFields', 'getFractionalValueField', 'getTotalValueField', 'getCurrentValueField', 'getTargetValueField', 'getCategoryField', 'getGroupingField', 'getStackingField', 'getCategoryLimit', 'getSideways', 'getVisualisationType', 'getVisualisationPosition', 'getVisualisationTitle']),\r\n        ...mapActions('dashboardModel', ['updateSelectionConfig']),\r\n        async isClicked (event) {\r\n            event.stopPropagation()\r\n            await this.updateSelectionConfig(this.config)\r\n        },\r\n        isEmpty (string) { return string === null || string === undefined || string === '' },\r\n        // Create dataset and save the dataset\r\n        async createAndSaveDataset () {\r\n            // Create data set\r\n            const dataset = await this.createDataset()\r\n            // Update visualisation dataset\r\n            this.dataSet = dataset\r\n            // Save dataset for sending to rl model\r\n            await this.saveVisualisationDataset({ config: this.config, dataset: dataset })\r\n        },\r\n        // Create dataset consisting of data, mapping, visualisation options and a title\r\n        async createDataset () {\r\n            // Collect data\r\n            var dataset = await this.collectData() // { mapping: ..., data: ... }\r\n            // console.log(dataset)\r\n            // Add options to dataset\r\n            dataset.options = await this.collectVisualisationOptions()\r\n            // Add title to data set\r\n            dataset.title = this.visualisationTitle\r\n\r\n            // Return dataset information\r\n            return dataset\r\n        },\r\n        async collectVisualisationOptions () {\r\n            var options = {}\r\n            // Add category limit\r\n            const categoryLimit = await this.getCategoryLimit()(this.config)\r\n            if (categoryLimit !== null && categoryLimit !== undefined) { options.categoryLimit = categoryLimit }\r\n            // Add sideways indicator\r\n            const sideways = await this.getSideways()(this.config)\r\n            if (sideways !== null && sideways !== undefined) { options.sideways = sideways }\r\n            const dataDisplayOptions = await this.getDataDisplay()(this.config)?.Options\r\n            // Add showValue indicator\r\n            const showValue = dataDisplayOptions?.ShowValue\r\n            if (showValue !== null && showValue !== undefined) { options.showValue = showValue }\r\n            // Add showArea indicator\r\n            const showArea = dataDisplayOptions?.ShowArea\r\n            if (showArea !== null && showArea !== undefined) { options.showArea = showArea }\r\n            // Add showBoundaryGap indicator\r\n            const showBoundaryGap = dataDisplayOptions?.ShowBoundaryGap\r\n            if (showBoundaryGap !== null && showBoundaryGap !== undefined) { options.showBoundaryGap = showBoundaryGap }\r\n            for (const optionKey in dataDisplayOptions) {\r\n                const option = dataDisplayOptions[optionKey]\r\n                if (option !== null && option !== undefined) {\r\n                    options[optionKey] = option\r\n                }\r\n            }\r\n            return options\r\n        },\r\n        // For each visualisation type create the corresponding dataset\r\n        async collectData () {\r\n            // return await this.createDatasetForFields(['Value Field', 'Value Fields', 'Fractional Value Field', 'Total Value Field', 'Current Value Field', 'Target Value Field'], ['Category Field', 'Stacking Field', 'Grouping Field'])\r\n            // Create dataset based for this visualisation type\r\n            switch (this.visualisationType) {\r\n                case 'Single Value Display':\r\n                    return await this.createDatasetForFields(['Value Field'])\r\n                case 'Fractional Value Display':\r\n                    return await this.createDatasetForFields(['Fractional Value Field', 'Total Value Field'])\r\n                case 'Progress Bar':\r\n                case 'Radial Progress Bar':\r\n                    return await this.createDatasetForFields(['Current Value Field', 'Target Value Field'])\r\n                case 'Pie Chart':\r\n                case 'Bar Chart':\r\n                case 'Line Chart':\r\n                case 'Table':\r\n                    return await this.createDatasetForFields(['Value Field'], ['Category Field'])\r\n                case 'Multi-Series Line Chart':\r\n                    return await this.createDatasetForFields(['Value Fields'], ['Category Field'])\r\n                case 'Grouped Bar Chart':\r\n                case 'Stacked Bar Chart':\r\n                    return await this.createDatasetForFields(['Value Field'], ['Category Field', 'Stacking Field', 'Grouping Field'])\r\n                default:\r\n                    return {}\r\n            }\r\n        },\r\n        async retrieveInfoForField (field, fieldName) {\r\n            if (field?.Indicators) {\r\n                return await this.retrieveIndicatorsInfo(field)\r\n            }\r\n            if (field?.Indicator) {\r\n                return await this.retrieveIndicatorInfo(field)\r\n            }\r\n            if (field?.['Named Field']) {\r\n                return await this.retrieveNamedFieldInfo(field)\r\n            }\r\n            if (field?.Values) {\r\n                return await this.retrieveFieldValuesInfo(field, fieldName)\r\n            }\r\n            return null\r\n        },\r\n        async getField (fieldName) {\r\n            switch (fieldName) {\r\n                case 'Value Field':\r\n                    return await this.getValueField()(this.config)\r\n                case 'Value Fields':\r\n                    return await this.getValueFields()(this.config)\r\n                case 'Fractional Value Field':\r\n                    return await this.getFractionalValueField()(this.config)\r\n                case 'Total Value Field':\r\n                    return await this.getTotalValueField()(this.config)\r\n                case 'Current Value Field':\r\n                    return await this.getCurrentValueField()(this.config)\r\n                case 'Target Value Field':\r\n                    return await this.getTargetValueField()(this.config)\r\n                case 'Category Field':\r\n                    return await this.getCategoryField()(this.config)\r\n                case 'Grouping Field':\r\n                    return await this.getGroupingField()(this.config)\r\n                case 'Stacking Field':\r\n                    return await this.getStackingField()(this.config)\r\n                case null:\r\n                case '':\r\n                default:\r\n                    return null\r\n            }\r\n        },\r\n        async retrieveIndicatorInfo (field) {\r\n            const fieldIndicator = field.Indicator\r\n            const fieldName = field.Name\r\n            const fieldFilters = field.Filters\r\n\r\n            // Get dataset for the current value field indicator\r\n            const indicatorDataSet = await this.getIndicatorDataSet()(fieldIndicator)\r\n            const indicatorName = indicatorDataSet.name\r\n            const indicatorData = await this.applyVisualisationFilters(indicatorDataSet.data, fieldFilters)\r\n\r\n            // Devise mapping for field\r\n            const fieldKey = indicatorName\r\n            const info = { key: fieldKey, name: fieldName, data: indicatorData, indicator: fieldIndicator }\r\n            return info\r\n        },\r\n        async retrieveIndicatorsInfo (field) {\r\n            const fieldIndicators = field.Indicators\r\n            const fieldName = field.Name\r\n            const fieldKey = this.isEmpty(fieldName) ? 'Value Field' : fieldName\r\n\r\n            var dataset = []\r\n            for (let indicatorNumber = 0; indicatorNumber < fieldIndicators.length; indicatorNumber++) {\r\n                const fieldIndicator = fieldIndicators[indicatorNumber]\r\n                if (!fieldIndicator) { continue }\r\n\r\n                // Get dataset for the current value field indicator\r\n                const indicatorDataSet = await this.getIndicatorDataSet()(fieldIndicator)\r\n                const indicatorName = indicatorDataSet.name\r\n                const indicatorData = await this.applyVisualisationFilters(indicatorDataSet.data)\r\n\r\n                // Collect data together with indicator name\r\n                const indicatorFieldKey = indicatorName\r\n                for (var row of indicatorData) {\r\n                    var rowData = {}\r\n                    rowData['Indicator Order'] = indicatorNumber\r\n                    rowData[fieldKey] = row[indicatorFieldKey]\r\n                    rowData.Year = row.Year\r\n                    dataset.push(rowData)\r\n                }\r\n            }\r\n\r\n            // Devise mapping for field\r\n            const info = { key: fieldKey, name: fieldName, data: dataset, indicators: fieldIndicators }\r\n            return info\r\n        },\r\n        async retrieveFieldValuesInfo (field, origFieldName) {\r\n            const fieldValues = field.Values\r\n            const fieldName = field.Name\r\n            const fieldKey = this.isEmpty(fieldName) ? (origFieldName ?? 'Category Field') : fieldName\r\n\r\n            var dataset = []\r\n            for (const fieldValue of fieldValues) {\r\n                var rowData = {}\r\n                rowData[fieldKey] = fieldValue\r\n                dataset.push(rowData)\r\n            }\r\n\r\n            // Devise mapping for field\r\n            const info = { key: fieldKey, name: fieldName, data: dataset, values: fieldValues }\r\n            return info\r\n        },\r\n        async retrieveNamedFieldInfo (field) {\r\n            const fieldKey = field['Named Field']\r\n            const fieldName = field.Name\r\n\r\n            // Devise mapping for field\r\n            const info = { key: fieldKey, name: fieldName, namedField: fieldName }\r\n            return info\r\n        },\r\n        // Apply filters to a dataset\r\n        async applyVisualisationFilters (dataSet, fieldFilters) {\r\n            const filters = await this.collectVisualisationFilters(fieldFilters)\r\n            if (filters && dataSet?.[0]) {\r\n                for (const filter of filters) {\r\n                    const filterField = filter.Field\r\n                    if (!Object.keys(dataSet[0]).includes(filterField)) continue\r\n                    const filterValues = filter.Values\r\n                    dataSet = dataSet.filter(row => filterValues.includes(row[filterField]))\r\n                }\r\n            }\r\n            return dataSet\r\n        },\r\n        // Collect filters\r\n        async collectVisualisationFilters (fieldFilters) {\r\n            // Get filters\r\n            const overviewFilters = await this.getOverviewFilters()(this.config) ?? []\r\n            const visualisationFilters = await this.getVisualisationFilters()(this.config) ?? []\r\n            // Combine and return filters\r\n            const combinedFilters = overviewFilters.concat(visualisationFilters).concat(fieldFilters ?? [])\r\n            return combinedFilters\r\n        },\r\n        // Summarize data by summing value fields for each grouping in the grouping fields\r\n        summarizeData (valueFields, groupingFields) {\r\n            // List for storing summarized rows accumulated so far\r\n            var accumulatedRows = []\r\n            // Summarize values for all value fields\r\n            for (const valueField of valueFields) {\r\n                const valueKey = valueField.key\r\n                const valueData = valueField.data\r\n                // For each row in data, add value to existing row or add new row with value\r\n                for (const row of valueData) {\r\n                    var groupingAlreadyPresent = false\r\n                    // Check if same grouping already exists in accumulated rows\r\n                    for (var accumulatedRow of accumulatedRows) {\r\n                        var sameGrouping = true\r\n                        for (const groupingField of groupingFields) {\r\n                            const groupingKey = (groupingField?.values !== undefined && groupingField?.values !== null) ? 'Indicator Order' : groupingField.key\r\n                            if (accumulatedRow[groupingKey] !== row[groupingKey]) {\r\n                                sameGrouping = false\r\n                                break\r\n                            }\r\n                        }\r\n                        // If so add value to current value\r\n                        if (sameGrouping) {\r\n                            const newValue = (accumulatedRow[valueKey] ?? 0) + (isNaN(row[valueKey]) ? 0 : Number(row[valueKey]))\r\n                            accumulatedRow[valueKey] = newValue\r\n                            groupingAlreadyPresent = true\r\n                            break\r\n                        }\r\n                    }\r\n                    // Otherwise if grouping is not present, add a new row for this grouping together with the value\r\n                    if (!groupingAlreadyPresent) {\r\n                        var newGroupingRow = {}\r\n                        const newValue = isNaN(row[valueKey]) ? 0 : Number(row[valueKey])\r\n                        newGroupingRow[valueKey] = newValue\r\n                        for (const groupingField of groupingFields) {\r\n                            newGroupingRow[groupingField.key] = row[groupingField.key]\r\n                            // Keep track of indicator order in case of duplicate category values\r\n                            if (groupingField?.values !== undefined && groupingField?.values !== null) {\r\n                                newGroupingRow['Indicator Order'] = row['Indicator Order']\r\n                            }\r\n                        }\r\n                        accumulatedRows.push(newGroupingRow)\r\n                    }\r\n                }\r\n            }\r\n            return accumulatedRows\r\n        },\r\n        async collectFields (fieldNames) {\r\n            var fieldsInfo = []\r\n            for (const fieldName of fieldNames) {\r\n                const field = await this.getField(fieldName)\r\n                if (!Array.isArray(field)) {\r\n                    var fieldInfo = await this.retrieveInfoForField(field, fieldName)\r\n                    if (fieldInfo === null) continue\r\n                    fieldInfo.fieldName = fieldName\r\n                    fieldsInfo.push(fieldInfo)\r\n                } else {\r\n                    for (let i = 0; i < field.length; i++) {\r\n                        var subFieldInfo = await this.retrieveInfoForField(field[i], fieldName)\r\n                        if (subFieldInfo === null) continue\r\n                        subFieldInfo.fieldName = fieldName + ' ' + i.toString()\r\n                        subFieldInfo.fieldNumber = i\r\n                        fieldsInfo.push(subFieldInfo)\r\n                    }\r\n                }\r\n            }\r\n            return fieldsInfo\r\n        },\r\n        async createDatasetForFields (valueFieldNames, groupingFieldNames = []) {\r\n            // Collect value fields\r\n            const valueFields = await this.collectFields(valueFieldNames)\r\n            // Collect grouping fields\r\n            const groupingFields = await this.collectFields(groupingFieldNames)\r\n\r\n            // Map category values to indicators\r\n            console.log(valueFields)\r\n            console.log(groupingFields)\r\n            this.mapCategoryValues(valueFields, groupingFields)\r\n\r\n            // Create dataset by summarizing data\r\n            var dataset = this.summarizeData(valueFields, groupingFields)\r\n            console.log(dataset)\r\n\r\n            // Sort dataset by year if this column is in dataset\r\n            const groupingKeys = groupingFields.map(field => field.key)\r\n            if (groupingKeys.includes('Year')) dataset = dataset.sort((a, b) => a.Year - b.Year)\r\n\r\n            // Create mapping from fields\r\n            const allFields = valueFields.concat(groupingFields)\r\n            const mapping = this.createMapping(allFields)\r\n\r\n            // Return data info\r\n            const dataSet = { data: dataset, mapping: mapping }\r\n            console.log(dataSet)\r\n            return dataSet\r\n        },\r\n        createMapping (fields) {\r\n            var mapping = {}\r\n            for (const field of fields) {\r\n                mapping[field.fieldName] = { key: field.key, name: field.name }\r\n            }\r\n            return mapping\r\n        },\r\n        mapCategoryValues (valueFields, groupingFields) {\r\n            // Map list of category values to list of indicators\r\n            console.log(valueFields, groupingFields)\r\n            for (const groupingField of groupingFields) {\r\n                const categoryValues = groupingField.values\r\n                if (categoryValues) {\r\n                    const categoryKey = groupingField.key\r\n                    for (const valueField of valueFields) {\r\n                        const valueIndicators = valueField.indicators\r\n                        if (valueIndicators) {\r\n                            const valueData = valueField.data\r\n                            for (var valueDataRow of valueData) {\r\n                                const valueFieldIndicatorOrder = valueDataRow['Indicator Order']\r\n                                valueDataRow[categoryKey] = categoryValues[valueFieldIndicatorOrder]\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style>\r\n.loading-container {\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n.progress-spinner {\r\n    max-height: 100%;\r\n    max-width: 100%;\r\n}\r\n</style>\r\n"]}]}